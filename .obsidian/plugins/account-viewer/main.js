/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AccountingViewerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var AccountingViewerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor("accounting", (source, el, ctx) => {
      const records = this.parseRecords(source);
      this.renderViews(records, el);
    });
  }
  parseRecords(source) {
    var _a, _b, _c, _d, _e, _f;
    const lines = source.split("\n");
    const records = [];
    let currentRecord = null;
    let balance_record = false;
    for (const line of lines) {
      if (line.trim() === "")
        continue;
      if (!line.startsWith("	") && !line.startsWith("   ")) {
        currentRecord && records.push(currentRecord);
        currentRecord = {
          type: line.trim().includes(" ") ? line.split(" ")[0] : line.trim(),
          param: line.trim().includes(" ") ? line.split(" ").slice(1).join(" ") : "",
          records: []
        };
      } else {
        if (!currentRecord)
          continue;
        switch (currentRecord.type) {
          case "transaction":
            currentRecord.records.push(line.split('"')[1].trim());
            break;
          case "entry":
            switch (true) {
              case line.trim().startsWith("page"):
                currentRecord.page = (_a = line.split('"')[1]) == null ? void 0 : _a.trim();
                break;
              case line.trim().startsWith("+"):
                currentRecord.records.push({
                  type: "DR",
                  account: line.split("+")[1].trim().split(":")[0].trim(),
                  amount: line.split("+")[1].trim().split(":")[1].trim(),
                  post_ref: (_b = line.split("+")[1].trim().split(":")[2]) == null ? void 0 : _b.trim()
                });
                break;
              case line.trim().startsWith("-"):
                currentRecord.records.push({
                  type: "CR",
                  account: line.split("-")[1].trim().split(":")[0].trim(),
                  amount: line.split("-")[1].trim().split(":")[1].trim(),
                  post_ref: (_c = line.split("-")[1].trim().split(":")[2]) == null ? void 0 : _c.trim()
                });
                break;
              case line.trim().startsWith("desc"):
                currentRecord.records.push({
                  type: "desc",
                  description: line.split('"')[1].trim()
                });
                break;
              default:
                break;
            }
            break;
          case "t-account":
            let record = {};
            switch (true) {
              case line.trim().startsWith("+"):
                record = {
                  type: "DR",
                  account: line.split("+")[1].trim().split(":")[0].trim(),
                  amount: line.split("+")[1].trim().split(":")[1].trim(),
                  post_ref: (_d = line.split("+")[1].trim().split(":")[2]) == null ? void 0 : _d.trim()
                };
                balance_record ? currentRecord.balance.push(record) : currentRecord.records.push(record);
                break;
              case line.trim().startsWith("-"):
                record = {
                  type: "CR",
                  account: line.split("-")[1].trim().split(":")[0].trim(),
                  amount: (_e = line.split("-")[1].trim().split(":")[1]) == null ? void 0 : _e.trim(),
                  post_ref: (_f = line.split("-")[1].trim().split(":")[2]) == null ? void 0 : _f.trim()
                };
                balance_record ? currentRecord.balance.push(record) : currentRecord.records.push(record);
                break;
              case line.trim().startsWith("balance"):
                balance_record = true;
                currentRecord.balance = [];
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
      }
    }
    currentRecord && records.push(currentRecord);
    return records;
  }
  renderViews(records, el) {
    records.forEach((record) => {
      switch (record.type) {
        case "transaction":
          this.renderTransactionTable(record, el);
          break;
        case "entry":
          this.renderJournalEntryTable(record, el);
          break;
        case "t-account":
          this.renderTAccountTable(record, el);
          break;
        default:
          break;
      }
      el.createEl("br");
    });
  }
  renderTransactionTable(record, el) {
    el.createEl("table", { cls: "transaction" }, (table) => {
      const tableHead = table.createEl("thead");
      const tableBody = table.createEl("tbody");
      const headRow = tableHead.createEl("tr");
      headRow.createEl("th", { text: "DATE", cls: "date" });
      headRow.createEl("th", { text: "TRANSACTION" });
      record.records.forEach((entry) => {
        const entryRow = tableBody.createEl("tr");
        entryRow.createEl("td", {
          text: record.param !== "" ? this.formatDate(record.param) : ""
        });
        entryRow.createEl("td", { text: entry });
      });
    });
  }
  renderJournalEntryTable(record, el) {
    const hasData = {
      page: false,
      date: false,
      account: false,
      post_ref: false,
      debit: false,
      credit: false
    };
    record.page !== void 0 && (hasData.page = true);
    record.param !== "" && (hasData.date = true);
    record.records.forEach((entry) => {
      if (entry.type === "DR") {
        hasData.account = true;
        hasData.post_ref = entry.post_ref !== void 0 ? true : hasData.post_ref;
        hasData.debit = true;
      }
      if (entry.type === "CR") {
        hasData.account = true;
        hasData.post_ref = entry.post_ref !== void 0 ? true : hasData.post_ref;
        hasData.credit = true;
      }
    });
    record.records.forEach(
      (entry) => {
        if (entry.type === "desc") {
          hasData.account = true;
        }
      }
    );
    const table = el.createEl("table", { cls: "journal-entry" });
    const tableHead = table.createEl("thead");
    const tableBody = table.createEl("tbody");
    const headPageRow = tableHead.createEl("tr");
    const pageHeader = headPageRow.createEl("th", { text: record.page, cls: "page-num" });
    pageHeader.setAttr("colspan", "5");
    record.page === void 0 && headPageRow.setAttr("hidden", "");
    const headRow = tableHead.createEl("tr");
    hasData.date && headRow.createEl("th", { text: "DATE", cls: "date" });
    hasData.account && headRow.createEl("th", { text: "ACCOUNTS", cls: "account-header" });
    hasData.post_ref && headRow.createEl("th", { text: "POST REF.", cls: "post-ref" });
    hasData.debit && headRow.createEl("th", { text: "DR." });
    hasData.credit && headRow.createEl("th", { text: "CR." });
    let onceShow = true;
    record.records.forEach((entry) => {
      const entryRow = tableBody.createEl("tr");
      hasData.date && entryRow.createEl("td", {
        cls: "date",
        text: onceShow ? this.formatDate(record.param) : ""
      });
      onceShow = false;
      if (entry.type === "desc") {
        hasData.account && entryRow.createEl("td", { text: entry.description, cls: "description" });
        hasData.post_ref && entryRow.createEl("td", { text: "" });
        hasData.debit && entryRow.createEl("td", { text: "" });
        hasData.credit && entryRow.createEl("td", { text: "" });
      } else {
        hasData.account && entryRow.createEl("td", {
          text: entry.account,
          cls: entry.type === "DR" ? "debit" : "credit"
        });
        hasData.post_ref && entryRow.createEl("td", { text: entry.post_ref });
        hasData.debit && entry.type === "DR" ? entryRow.createEl("td", { text: entry.amount }) : entryRow.createEl("td", { text: "" });
        hasData.credit && entry.type === "CR" ? entryRow.createEl("td", { text: entry.amount }) : entryRow.createEl("td", { text: "" });
      }
    });
  }
  renderTAccountTable(record, el) {
    el.createEl("table", { cls: "t-account" }, (table) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const head = table.createEl("thead");
      const body = table.createEl("tbody");
      const headerRow = head.createEl("tr");
      headerRow.createEl("th", { text: record.param, cls: "account-header" }).setAttr("colspan", "4");
      let debits = [];
      let credits = [];
      record.records.forEach((entry) => {
        if (entry.type === "DR") {
          debits.push({
            account: entry.account,
            amount: entry.amount
          });
        }
        if (entry.type === "CR") {
          credits.push({
            account: entry.account,
            amount: entry.amount
          });
        }
      });
      const steps = debits.length > credits.length ? debits.length : credits.length;
      for (let i = 0; i < steps; i++) {
        const entryRow = body.createEl("tr");
        entryRow.createEl("td", { text: (_a = debits[i]) == null ? void 0 : _a.account });
        entryRow.createEl("td", { text: (_b = debits[i]) == null ? void 0 : _b.amount });
        entryRow.createEl("td", { text: (_c = credits[i]) == null ? void 0 : _c.account });
        entryRow.createEl("td", { text: (_d = credits[i]) == null ? void 0 : _d.amount });
      }
      let debitsBalance = [];
      let creditsBalance = [];
      if (record.balance !== void 0) {
        record.balance.forEach((entry) => {
          if (entry.type === "DR") {
            debitsBalance.push({
              account: entry.account,
              amount: entry.amount
            });
          }
          if (entry.type === "CR") {
            creditsBalance.push({
              account: entry.account,
              amount: entry.amount
            });
          }
        });
      }
      const stepsBalance = debitsBalance.length > creditsBalance.length ? debitsBalance.length : creditsBalance.length;
      for (let i = 0; i < stepsBalance; i++) {
        const entryRow = body.createEl("tr", { cls: "balance-row" });
        entryRow.createEl("td", { text: (_e = debitsBalance[i]) == null ? void 0 : _e.account });
        entryRow.createEl("td", { text: (_f = debitsBalance[i]) == null ? void 0 : _f.amount });
        entryRow.createEl("td", { text: (_g = creditsBalance[i]) == null ? void 0 : _g.account });
        entryRow.createEl("td", { text: (_h = creditsBalance[i]) == null ? void 0 : _h.amount });
      }
    });
  }
  formatDate(date) {
    const [day, month, year] = date.split("-");
    return new Date(`${year}-${month}-${day}`).toLocaleDateString(
      "en-US",
      { year: "numeric", month: "short", day: "numeric" }
    );
  }
  onunload() {
  }
};

/* nosourcemap */